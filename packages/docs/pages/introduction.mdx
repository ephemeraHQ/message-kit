# Introduction

MessageKit's Skill framework enables agents to process natural language through multiple intelligence layers. Agents can:

- Handle multi-step conversations
- Maintain context
- Wait for user responses
- Create natural interaction flows

![](/img/skills.png)

## How it works

Let's walk through a complete ENS domain registration flow:

:::steps

### User request

```bash
who holds vitalik.eth
```

### Parsing

The agent processes the natural language input and breaks it down into sequential steps:

```bash
[
  "Hello! I'll help you get your domain.",
  "Let's start by checking your ENS domain. Give me a moment.",
  "/info vitalik.eth",
]
```

This is the parameters extracted from the user request and available to the handler:

```json
{
  "skill": "info",
  "params": {
    "domain": "vitalik.eth"
  }
}
```

> This happens in the `processMultilineResponse` in the GPT [plugin](/plugins/gpt).

### Skill declaration

The handler function to process check skill requests:

```tsx [src/skills/info.ts]
// [!include ~/../../templates/ens/src/skills/info.ts:define]
```

### Handler

The handler function to process info skill requests to fetch information about an ENS domain:

```tsx [src/skills/info.ts]
// [!include ~/../../templates/ens/src/skills/info.ts:handle]
```

### System prompt

Here is the prompt for the agent.

```jsx [src/prompt.ts]
export const systemPrompt = `{intro}

{vibe}

{rules}

{user_context}

{skills}
`;
```

### Agent

This is the main function that runs the listener.

```jsx
import { Agent, run, type Context } from "@xmtp/message-kit";

const agent: Agent = {
  name: "Agent Name",
  tag: "@bot",
  description: "Agent Description",
  skills: [skill1, skill2],
};

//starts the agent
run(agent);
```

### End result

The end result is a prompt that the model can understand and use to respond to the user.

```md [example_prompt.md]
// [!include ~/../../templates/ens/example_prompt.md]
```

:::
