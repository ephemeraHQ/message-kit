# Reasoning

Agents can handle complex conversations by managing multiple steps in sequence, maintaining context, and waiting for user responses. This creates a more natural interaction flow.

## Overview

For full reasoning we need to combine the following skills:

- [Fine-Tuning](/skills/fine-tuning): Train your agent for reliable responses.
- [Prompting](/skills/prompting): System prompt to teach available skills to the agent.
- [Processing](/skills/processing): Handle multiple skills in a single conversation.
- [Parsing](/skills/parsing): Interpret user intent and translate it into a defined skill.
- [Definition](/skills/definition): Define skills, parameters and handlers.

## Example: Ens domain registration

Now let's put all these powerfull pieces together to create a more complex interaction.

Let's walk through a complete ENS domain registration flow:

:::steps

### User initiates the conversation

```bash
lets register fabriethsf.eth
```

### Skills definition

```tsx
export const skills: SkillGroup[] = [
  {
    name: "Ens Domain Bot",
    tag: "@ens",
    description: "Register ENS domains.",
    skills: [
      {
        skill: "/register [domain]",
        triggers: ["/register"],
        handler: handleEns,
        description:
          "Register a new ENS domain. Returns a URL to complete the registration process.",
        examples: ["/register vitalik.eth"],
        params: {
          domain: {
            type: "string",
          },
        },
      },
      {
        skill: "/exists",
        examples: ["/exists"],
        handler: handleEns,
        triggers: ["/exists"],
        description: "Check if an address is onboarded.",
        params: {
          address: {
            type: "address",
          },
        },
      },
      /* More Skills */
    ],
  },
];
```

### Handler implementation

```tsx
const {
  message: {
    sender,
    content: { skill, params },
  },
} = context;

if (skill == "check") {
  const { domain } = params;

  const data = await getUserInfo(domain);
  if (!data?.address) {
    let message = `Looks like ${domain} is available! 
    Here you can register it: ${ensUrl}${domain} or would you like to see 
    some cool alternatives?`;
    return {
      code: 200,
      message,
    };
  } else {
    let message = `Looks like ${domain} is already registered!`;
    await context.executeSkill("/cool " + domain);
    return {
      code: 404,
      message,
    };
  }
}
```

### Creating a response

The agent processes the natural language input "lets register fabriethsf.eth" and breaks it down into sequential steps:

```tsx
import { run, HandlerContext } from "@xmtp/message-kit";
import { textGeneration, processMultilineResponse } from "@xmtp/message-kit";
import { agent_prompt } from "./prompt.js";

run(async (context: HandlerContext) => {
  const {
    message: {
      content: { text, params },
      sender,
    },
  } = context;

  try {
    let userPrompt = params?.prompt ?? text;
    const { reply } = await textGeneration(
      sender.address,
      userPrompt,
      await agent_prompt(sender.address),
    );
    await processMultilineResponse(sender.address, reply, context);
  } catch (error) {
    console.error("Error during OpenAI call:", error);
    await context.send("An error occurred while processing your request.");
  }
});
```

:::

This is a very simple example, but it shows how the agent can handle complex interactions by managing multiple steps in sequence, maintaining context, and waiting for user responses.
