# Reasoning

Agents can handle complex conversations by managing multiple steps in sequence, maintaining context, and waiting for user responses. This creates a more natural interaction flow.

## Overview

For full reasoning we need to combine the following skills:

- [Fine-Tuning](/skills/fine-tuning): Train your agent for reliable responses.
- [Prompting](/skills/prompting): System prompt to teach available skills to the agent.
- [Processing](/skills/processing): Handle multiple skills in a single conversation.
- [Parsing](/skills/parsing): Interpret user intent and translate it into a defined skill.
- [Definition](/skills/definition): Define skills, parameters and handlers.

## Example: Ens domain registration

Now let's put all these powerfull pieces together to create a more complex interaction.

Let's walk through a complete ENS domain registration flow:

:::steps

### User initiates the conversation

```bash
let's register fabriethsf.eth
```

### Skills definition

```tsx
import { SkillGroup } from "@xmtp/message-kit";
import { handler as handleRegister } from "./handler/register.js";
import { handler as handleExists } from "./handler/exists.js";

export const skills: SkillGroup[] = [
  {
    name: "Ens Domain Bot",
    tag: "@ens",
    description: "Register ENS domains.",
    skills: [
      {
        skill: "/register [domain]",
        handler: handleRegister,
        description:
          "Register a new ENS domain. Returns a URL to complete the registration process.",
        examples: ["/register vitalik.eth"],
        params: {
          domain: {
            type: "string",
          },
        },
      },
      {
        skill: "/exists",
        examples: ["/exists"],
        handler: handleExists,
        description: "Check if an address is onboarded.",
        params: {
          address: {
            type: "address",
          },
        },
      },
      /* More Skills */
    ],
  },
];
```

### Handler implementation

```tsx
import { ensUrl } from "../skills.js";
import { XMTPContext, getUserInfo } from "@xmtp/message-kit";

export async function handleCheck(context: XMTPContext) {
  const {
    message: {
      content: {
        params: { domain },
      },
    },
  } = context;

  const data = await getUserInfo(domain);
  if (!data?.address) {
    let message = `Looks like ${domain} is available! Here you can register it: ${ensUrl}${domain} or would you like to see some cool alternatives?`;
    return {
      code: 200,
      message,
    };
  } else {
    let message = `Looks like ${domain} is already registered!`;
    await context.executeSkill("/cool " + domain);
    return {
      code: 404,
      message,
    };
  }
}
```

### Creating a response

The agent processes the natural language input "let's register fabriethsf.eth" and breaks it down into sequential steps:

```tsx
import {
  run,
  XMTPContext,
  agentReply,
  replaceVariables,
} from "@xmtp/message-kit";
import { skills } from "./skills.js";
import { systemPrompt } from "./prompt.js";

run(
  async (context: XMTPContext) => {
    const {
      message: { sender },
      runConfig,
    } = context;

    let prompt = await replaceVariables(
      systemPrompt,
      sender.address,
      runConfig?.skills,
      "@bot",
    );
    await agentReply(context, prompt);
  },
  { skills },
);
```

:::

This is a very simple example, but it shows how the agent can handle complex interactions by managing multiple steps in sequence, maintaining context, and waiting for user responses.
