# Reasoning

Agents can handle complex conversations by managing multiple steps in sequence, maintaining context, and waiting for user responses. This creates a more natural interaction flow.

## Overview

For full reasoning we need to combine the following skills:

- [Fine-Tuning](/skills/fine-tuning): Train your agent for reliable responses.
- [Prompting](/skills/prompting): System prompt to teach available skills to the agent.
- [Processing](/skills/processing): Handle multiple skills in a single conversation.
- [Parsing](/skills/parsing): Interpret user intent and translate it into a defined skill.
- [Definition](/skills/definition): Define skills, parameters and handlers.

## Example: Ens domain registration

Now let's put all these powerfull pieces together to create a more complex interaction.

Let's walk through a complete ENS domain registration flow:

:::steps

### User initiates the conversation

```bash
let's register fabriethsf.eth
```

### Skills definition

```tsx
import { SkillGroup } from "@xmtp/message-kit";
import { handler as handleRegister } from "./handler/register.js";
import { handler as handleExists } from "./handler/exists.js";

export const skills: SkillGroup[] = [
  {
    name: "Ens Domain Bot",
    tag: "@ens",
    description: "Register ENS domains.",
    skills: [
      {
        skill: "/register [domain]",
        handler: handleRegister,
        description:
          "Register a new ENS domain. Returns a URL to complete the registration process.",
        examples: ["/register vitalik.eth"],
        params: {
          domain: {
            type: "string",
          },
        },
      },
      {
        skill: "/exists",
        examples: ["/exists"],
        handler: handleExists,
        description: "Check if an address is onboarded.",
        params: {
          address: {
            type: "address",
          },
        },
      },
      /* More Skills */
    ],
  },
];
```

### Handler implementation

The handler function to process check skill requests:

```tsx [src/handlers/check.ts]
// [!include ~/../../templates/agent/src/handlers/check.ts]
```

### Creating a response

The agent processes the natural language input "let's register fabriethsf.eth" and breaks it down into sequential steps:

```tsx [src/index.ts]
// [!include ~/../../templates/agent/src/index.ts]
```

:::

This is a very simple example, but it shows how the agent can handle complex interactions by managing multiple steps in sequence, maintaining context, and waiting for user responses.
