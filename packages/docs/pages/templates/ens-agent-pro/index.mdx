# Ens Agent Pro

This example uses langchain to create an agent that can use various tools to help users with their ENS domains.

## Agent

```tsx
import { run, XMTPContext } from "@xmtp/message-kit";
import { ChatOpenAI } from "@langchain/openai";
import { createOpenAIFunctionsAgent, AgentExecutor } from "langchain/agents";
import { tools } from "./skills.js";
import { systemPrompt } from "./prompt.js";
import { ChatPromptTemplate } from "@langchain/core/prompts";

// Initialize OpenAI chat model
const model = new ChatOpenAI({
  temperature: 0.7,
  modelName: "gpt-4o-mini",
});

// Create the prompt template with required variables
const prompt = ChatPromptTemplate.fromMessages([
  ["system", systemPrompt],
]).partial({
  tools: tools.map((tool) => `${tool.name}: ${tool.description}`).join("\n"),
  tool_names: tools.map((tool) => tool.name).join(", "),
});

// Initialize chat history storage
const chatHistory = new Map<string, { role: string; content: string }[]>();

// Initialize the agent and executor
const initializeAgent = async () => {
  const agent = await createOpenAIFunctionsAgent({
    llm: model,
    tools,
    prompt: await prompt,
  });

  return new AgentExecutor({
    agent,
    tools,
    returnIntermediateSteps: false,
    verbose: true, // Set to true for checking the agent's thought process
  });
};

// Create executor instance
const executor = await initializeAgent();

run(
  async (context: XMTPContext) => {
    const {
      message: {
        content: { text },
        sender,
      },
    } = context;

    console.log("Received message:", text);

    // Get or initialize chat history for this sender
    if (!chatHistory.has(sender.address)) {
      chatHistory.set(sender.address, []);
    }
    const userHistory: any = chatHistory.get(sender.address)!;

    // Add user message to history
    userHistory.push({ role: "user", content: context.message.content.text });

    try {
      // Execute agent with user's message and chat history
      const result = await executor.invoke({
        input: text,
        chat_history: userHistory,
      });

      console.log("Agent response:", result.output);
      const output = result.output.replace(/\*/g, "");

      // Add assistant's response to history
      userHistory.push({ role: "assistant", content: output });

      await context.send(output);
    } catch (error) {
      console.error("Error:", error);
      // Add error message to history
      userHistory.push({
        role: "assistant",
        content: "An error occurred while processing your request.",
      });
      await context.send("An error occurred while processing your request.");
    }
  },
  { skills: [] },
);
```

## Prompt

```tsx
export const systemPrompt = `You are a helpful AI assistant that can use various tools to help users.

You have access to the following tools:
{tools}

Tool Names: {tool_names}

Instructions:
1. DO NOT respond in markdown. ALWAYS respond in plain text.
2. Use tools when appropriate
3. Be friendly and helpful
4. Ask for clarification if you don't understand the user's request
5. For tipping, always confirm the amount with the user once

Previous conversation history:
{chat_history}

User Input: {input}
{agent_scratchpad}`;
```

## Skills

```tsx
import { DynamicStructuredTool } from "langchain/tools";
import { getUserInfo, clearInfoCache, isOnXMTP } from "@xmtp/message-kit";
import { clearMemory } from "@xmtp/message-kit";
import { isAddress } from "viem";
import { z } from "zod";

const frameUrl = "https://ens.steer.fun/";
const ensUrl = "https://app.ens.domains/";
const txpayUrl = "https://txpay.vercel.app";
const converseUrl = "https://converse.xyz/profile/";

// Add interface for Converse API response
interface ConverseProfile {
  address: string;
  avatar?: string;
  formattedName?: string;
  name?: string;
  onXmtp: boolean;
}

// Add function to check XMTP status
async function checkXMTPStatus(address: string): Promise<boolean> {
  try {
    const response = await fetch(converseUrl + address, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify({ address }),
    });

    if (!response.ok) {
      console.error(`Failed to check XMTP status: ${response.status}`);
      return false;
    }

    const data = (await response.json()) as ConverseProfile;
    return data.onXmtp;
  } catch (error) {
    console.error("Error checking XMTP status:", error);
    return false;
  }
}

const generateCoolAlternatives = (domain: string) => {
  const suffixes = ["lfg", "cool", "degen", "moon", "base", "gm"];
  const alternatives = [];
  for (let i = 0; i < 5; i++) {
    const randomPosition = Math.random() < 0.5;
    const baseDomain = domain.replace(/\.eth$/, ""); // Remove any existing .eth suffix
    alternatives.push(
      randomPosition
        ? `${suffixes[i]}${baseDomain}.eth`
        : `${baseDomain}${suffixes[i]}.eth`,
    );
  }

  return alternatives
    .map(
      (alternative: string, index: number) => `${index + 1}. ${alternative} âœ¨`,
    )
    .join("\n");
};

// Export tools array with all tools
export const tools = [
  new DynamicStructuredTool({
    name: "reset_ens_conversation",
    description: "Reset the ENS conversation and clear memory",
    schema: z.object({}),
    func: async () => {
      clearMemory();
      return "Conversation reset successfully.";
    },
  }),

  new DynamicStructuredTool({
    name: "renew_ens_domain",
    description:
      "Generate renewal URL for an ENS domain. Only works if sender owns the domain",
    schema: z.object({
      domain: z.string().describe("The ENS domain to renew"),
    }),
    func: async ({ domain }) => {
      const data = await getUserInfo(domain);
      if (!data?.address) {
        return "Domain not found or not registered.";
      }
      return `${frameUrl}frames/manage?name=${domain}`;
    },
  }),

  new DynamicStructuredTool({
    name: "register_ens_domain",
    description: "Get URL to register a new ENS domain",
    schema: z.object({
      domain: z.string().describe("The ENS domain to register"),
    }),
    func: async ({ domain }) => {
      if (!domain) return "Please provide a domain name";
      return `${ensUrl}${domain}`;
    },
  }),

  new DynamicStructuredTool({
    name: "get_ens_info",
    description:
      "Get detailed information about an ENS domain including owner, avatar, description, etc",
    schema: z.object({
      domain: z.string().describe("The ENS domain to get information about"),
    }),
    func: async ({ domain }) => {
      const data = await getUserInfo(domain);
      if (!data?.ensDomain) {
        return "Domain not found.";
      }

      const formattedData = {
        Address: data?.address,
        "Avatar URL": data?.ensInfo?.avatar,
        Description: data?.ensInfo?.description,
        ENS: data?.ensDomain,
        "Primary ENS": data?.ensInfo?.ens_primary,
        GitHub: data?.ensInfo?.github,
        Resolver: data?.ensInfo?.resolverAddress,
        Twitter: data?.ensInfo?.twitter,
        URL: `${ensUrl}${domain}`,
      };

      let message = "Domain information:\n\n";
      for (const [key, value] of Object.entries(formattedData)) {
        if (value) {
          message += `${key}: ${value}\n`;
        }
      }
      message +=
        "\nWould you like to tip the domain owner for getting there first? ðŸ¤£";

      // Check XMTP status if we have an address
      if (data.address) {
        const isOnXMTP = await checkXMTPStatus(data.address);
        if (isOnXMTP) {
          message += `\n\nAh, this domain is on XMTP! You can message it directly: https://converse.xyz/dm/${domain}`;
        }
      }

      return message;
    },
  }),

  new DynamicStructuredTool({
    name: "check_ens_availability",
    description: "Check if an ENS domain is available for registration",
    schema: z.object({
      domain: z
        .string()
        .transform((str) => str.replace(/^["'](.+)["']$/, "$1")) // Remove quotes if present
        .transform((str) => str.toLowerCase())
        .describe("The ENS domain to check availability for"),
    }),
    func: async ({ domain }) => {
      if (!domain) return "Please provide a domain name to check.";

      if (domain.includes(".") && !domain.endsWith(".eth")) {
        return "Invalid ENS domain. Only .eth domains are supported.";
      }

      if (!domain.includes(".")) {
        domain = `${domain}.eth`;
      }

      const data = await getUserInfo(domain);
      if (!data?.address) {
        return `Looks like ${domain} is available! Here you can register it: ${ensUrl}${domain} or would you like to see some cool alternatives?`;
      } else {
        const alternatives = generateCoolAlternatives(domain);
        return `Looks like ${domain} is already registered!\n\nHere are some cool alternatives:\n${alternatives}`;
      }
    },
  }),

  new DynamicStructuredTool({
    name: "get_ens_alternatives",
    description: "Generate cool alternative names for an ENS domain",
    schema: z.object({
      domain: z
        .string()
        .describe("The ENS domain to generate alternatives for"),
    }),
    func: async ({ domain }) => {
      if (!domain) return "Please provide a domain name.";
      return `What about these cool alternatives?\n\n${generateCoolAlternatives(domain)}`;
    },
  }),

  new DynamicStructuredTool({
    name: "get_ens_tip_url",
    description:
      "Generate a URL to tip an ENS domain owner in USDC. Works with both ENS domains and Ethereum addresses.",
    schema: z.object({
      addressOrDomain: z
        .string()
        .describe("The ENS domain or Ethereum address to tip"),
      amount: z
        .number()
        .optional()
        .default(1)
        .describe("The amount of USDC to tip"),
    }),
    func: async ({ addressOrDomain, amount }) => {
      if (!addressOrDomain) {
        return "Please provide an address or ENS domain to tip.";
      }

      let address: string | undefined;

      if (isAddress(addressOrDomain)) {
        address = addressOrDomain;
      } else {
        const data = await getUserInfo(addressOrDomain);
        address = data?.address;
      }

      if (!address) {
        return "Could not resolve address for tipping. Please provide a valid ENS domain or Ethereum address.";
      }

      let sendUrl = `${txpayUrl}/?&amount=${amount}&token=USDC&receiver=${address}`;
      return sendUrl;
    },
  }),
];
```
